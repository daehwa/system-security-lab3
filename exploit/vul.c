#include <asm/uaccess.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/device.h>
#include <linux/fs.h>
#include <linux/sched.h>
#include <linux/thread_info.h>

#define DEVICE_NAME "vul"
#define CLASS_NAME "vul"

MODULE_LICENSE("GPL");

static int vul_open(struct inode *inodep, struct file *filep);
static int vul_release(struct inode *inodep, struct file *filep);
static int vul_read(struct file *filep, char* buffer,
        size_t len, loff_t *offset);
static int vul_write(struct file *filep, const char* buffer,
        size_t len, loff_t *offset);


static struct file_operations fops = {
    .open = vul_open,
    .release = vul_release,
    .read = vul_read,
    .write = vul_write,
};

static struct {
    int open;
} dev_vul;
static int major_number;
static struct class* vul_class;
static struct device* vul_device;



static int vul_open(struct inode *inodep, struct file *filep) {
    if (dev_vul.open == 0) {
        pr_info("%s: vul opens\n",__func__);
        dev_vul.open = 1;
        return 0;
    }
    else {
        pr_info("%s: open already\n",__func__);
        return -EALREADY;
    }
}

static int vul_release(struct inode *inodep, struct file *filep) {
    if (dev_vul.open == 1) {
        pr_info("%s: vul is being released\n",__func__);
        dev_vul.open = 0;
    }
    else {
        pr_info("%s: not open?\n",__func__);
    }
    return 0;
}

static int vul_read(struct file *filep, char *buffer, size_t len, loff_t *offset) {
    unsigned int data[256];
    memcpy(buffer, &data[255-len], 0x4);
    return 4;
}


static int vul_write(struct file *filep, const char *buffer, size_t len, loff_t *offset) {
    unsigned int data[256];
    memcpy(&data[255-len],buffer,4);
    return 4;
}


static int vul_init(void) {
    pr_info("%s: vul\n",__func__);

    dev_vul.open = 0;

    major_number = register_chrdev(0, DEVICE_NAME, &fops);
    if (major_number < 0) {
        pr_alert("Failed to get a major number\n");
        return major_number;
    }
    pr_info("%s: got major number: %d\n",__func__, major_number);
    vul_class = class_create(THIS_MODULE, CLASS_NAME);
    if (IS_ERR(vul_class)) {
        unregister_chrdev(major_number, DEVICE_NAME);
        pr_alert("Failed to register device class for vul\n");
        return PTR_ERR(vul_class);
    }
    vul_device = device_create(vul_class, NULL,
            MKDEV(major_number, 0),
            NULL,
            DEVICE_NAME);
    if(IS_ERR(vul_device)) {
        class_destroy(vul_class);
        unregister_chrdev(major_number, DEVICE_NAME);
        pr_alert("Failed to create the device for vul\n");
        return PTR_ERR(vul_device);
    }
    pr_info("%s: create the vul device!\n",__func__);
    return 0;
}

static void vul_exit(void) {
    device_destroy(vul_class, MKDEV(major_number, 0));
    class_unregister(vul_class);
    class_destroy(vul_class);
    unregister_chrdev(major_number, DEVICE_NAME);
    pr_info("%s: bye!\n",__func__);
    return;
}

module_init(vul_init);
module_exit(vul_exit);

